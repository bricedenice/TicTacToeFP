<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FunctionalGame.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Functional Tic-Tac-Toe Game</a> &gt; <a href="index.source.html" class="el_package">com.example.tictactoe.fp</a> &gt; <span class="el_source">FunctionalGame.java</span></div><h1>FunctionalGame.java</h1><pre class="source lang-java linenums">package com.example.tictactoe.fp;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;



<span class="fc" id="L13">public class FunctionalGame {</span>
    /* In an enterprise environment,
     the constants will be contained in its own class to separate
     the Main (FunctionalGame) class and storing the constants.*/
    private static final int BOARD_SIZE = 3;
    private static final char EMPTY_CELL = ' ';
    private static final String BOARD_BORDER = &quot;---------&quot;;
<span class="fc" id="L20">    private static final Random RANDOM = new Random();</span>
    /*
    Reuse Random instance, Supplier&lt;Random&gt; would be a flexible enterprise solution.
    Allowing one to, for instance, lazily evaluate and set particular logic
    to select different levels of Random generation, prioritized by speed or security.

    public class MonitoredGameConfiguration {
    private final Supplier&lt;Random&gt; randomSupplier;
    private final MetricsCollector metrics;

    public MonitoredGameConfiguration(MetricsCollector metrics) {
        this.metrics = metrics;
        this.randomSupplier = () -&gt; {
            long startTime = System.nanoTime();

            Random random = createOptimalRandom();

            long creationTime = System.nanoTime() - startTime;
            metrics.recordRandomCreationTime(creationTime);

            return random;
        };
    }

    private Random createOptimalRandom() {
        // Government systems need performance metrics
        if (metrics.getAverageCreationTime() &gt; MAX_ALLOWED_TIME) {
            return ThreadLocalRandom.current(); // Faster option
        } else {
            return new SecureRandom(); // More secure option
        }
    }
}
     */

    // enums would be in its own class as well,
<span class="fc" id="L56">    public enum PlayerType {</span>
<span class="fc" id="L57">        USER,</span>
<span class="fc" id="L58">        EASY,</span>
<span class="fc" id="L59">        MEDIUM,</span>
<span class="fc" id="L60">        HARD;</span>

        // Helper method to check if player is &quot;AI&quot;
        public boolean isAI() {
<span class="fc bfc" id="L64" title="All 2 branches covered.">            return this != USER;</span>
        }
    }

/*  Records are essential for removing boiler, maintaining immutability
    by capturing the complete game state at any moment.
    Additionally, key information for the instance like Player and GameConfig are encapsulated.*/
<span class="fc" id="L71">public record GameState(List&lt;List&lt;Character&gt;&gt; board, char currentPlayer, int moveCount) {}</span>
<span class="fc" id="L72">    public record Player(String name, char mark, PlayerType type) {}</span>
<span class="fc" id="L73">    public record GameConfig(Player player1, Player player2) {}</span>


    // Each method maintains immutability where it can, Scanner I/O is mutable by function as it must change with input
    public List&lt;List&lt;Character&gt;&gt; createEmptyBoard(int size, char emptyCell) { // Using Monadic composition
<span class="fc" id="L78">        return IntStream.range(0, size)</span>
<span class="fc" id="L79">                .mapToObj(i -&gt; Collections.nCopies(size, emptyCell))</span>
<span class="fc" id="L80">                .toList();</span>
    }

    public String formatBoard(List&lt;List&lt;Character&gt;&gt; board) {
<span class="fc" id="L84">        return BOARD_BORDER + &quot;\n&quot; +</span>
<span class="fc" id="L85">                board.stream()</span>
<span class="fc" id="L86">                        .map(row -&gt; &quot;| &quot; + row.stream().map(String::valueOf).collect(Collectors.joining(&quot; &quot;)) + &quot; |&quot;)</span>
<span class="fc" id="L87">                        .collect(Collectors.joining(&quot;\n&quot;)) +</span>
                &quot;\n&quot; + BOARD_BORDER;
    }


    public Optional&lt;GameState&gt; tryMove(GameState state, int row, int col, char mark) {
<span class="fc bfc" id="L93" title="All 8 branches covered.">        if (row &gt;= 0 &amp;&amp; row &lt; BOARD_SIZE &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; BOARD_SIZE &amp;&amp;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                state.board().get(row).get(col) == EMPTY_CELL) {</span>
<span class="fc" id="L95">            List&lt;List&lt;Character&gt;&gt; newBoard = state.board().stream()</span>
<span class="fc" id="L96">                    .map(r -&gt; r.stream().collect(Collectors.toList()))</span>
<span class="fc" id="L97">                    .collect(Collectors.toList());</span>
<span class="fc" id="L98">            newBoard.get(row).set(col, mark);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">            return Optional.of(new GameState(newBoard, state.currentPlayer() == 'X' ? 'O' : 'X', state.moveCount() + 1));</span>
        }
<span class="fc" id="L101">        return Optional.empty();</span>
    }

    public boolean hasWon(List&lt;List&lt;Character&gt;&gt; board, char mark) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        boolean rowWin = board.stream().anyMatch(row -&gt; row.stream().allMatch(c -&gt; c == mark));</span>
<span class="fc" id="L106">        boolean colWin = IntStream.range(0, BOARD_SIZE)</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">                .anyMatch(col -&gt; board.stream().allMatch(row -&gt; row.get(col) == mark));</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        boolean diag1Win = IntStream.range(0, BOARD_SIZE).allMatch(i -&gt; board.get(i).get(i) == mark);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">        boolean diag2Win = IntStream.range(0, BOARD_SIZE).allMatch(i -&gt; board.get(i).get(BOARD_SIZE - 1 - i) == mark);</span>
<span class="fc bfc" id="L110" title="All 8 branches covered.">        return rowWin || colWin || diag1Win || diag2Win;</span>
    }

    public boolean isDraw(GameState state) {
<span class="fc bfc" id="L114" title="All 2 branches covered.">        return state.moveCount() == BOARD_SIZE * BOARD_SIZE;</span>
    }

    public Optional&lt;GameState&gt; tryUserMove(GameState state, String input) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (input.matches(&quot;[1-3] [1-3]&quot;)) {</span>
<span class="fc" id="L119">            String[] parts = input.split(&quot; &quot;);</span>
<span class="fc" id="L120">            int row = Integer.parseInt(parts[0]) - 1;</span>
<span class="fc" id="L121">            int col = Integer.parseInt(parts[1]) - 1;</span>
<span class="fc" id="L122">            return tryMove(state, row, col, state.currentPlayer());</span>
        }
<span class="fc" id="L124">        return Optional.empty();</span>
    }

    public Optional&lt;GameState&gt; tryRandomMove(GameState state, Random random, char mark) {
<span class="fc" id="L128">        List&lt;int[]&gt; emptyCells = IntStream.range(0, BOARD_SIZE)</span>
<span class="fc" id="L129">                .boxed()</span>
<span class="fc" id="L130">                .flatMap(i -&gt; IntStream.range(0, BOARD_SIZE)</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">                        .filter(j -&gt; state.board().get(i).get(j) == EMPTY_CELL)</span>
<span class="fc" id="L132">                        .mapToObj(j -&gt; new int[]{i, j}))</span>
<span class="fc" id="L133">                .collect(Collectors.toList());</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (emptyCells.isEmpty()) {</span>
<span class="nc" id="L135">            return Optional.empty();</span>
        }
<span class="fc" id="L137">        int[] move = emptyCells.get(random.nextInt(emptyCells.size()));</span>
<span class="fc" id="L138">        return tryMove(state, move[0], move[1], mark);</span>
    }

    // Medium AI strategy (try to win, block, or random)
    public Optional&lt;GameState&gt; tryMediumMove(GameState state, char mark) {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        char opponentMark = (mark == 'X') ? 'O' : 'X';</span>

        // First, try to win
<span class="fc" id="L146">        Optional&lt;GameState&gt; winMove = tryWinningMove(state, mark);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">        if (winMove.isPresent()) {</span>
<span class="nc" id="L148">            return winMove;</span>
        }

        // Second, try to block opponent
<span class="fc" id="L152">        Optional&lt;GameState&gt; blockMove = tryWinningMove(state, opponentMark);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (blockMove.isPresent()) {</span>
            // Convert opponent winning move to our blocking move
<span class="fc" id="L155">            return blockMove.map(blockedState -&gt; {</span>
                // Find where opponent would win and place our mark there instead
<span class="fc" id="L157">                return findBlockingMove(state, opponentMark, mark);</span>
<span class="fc" id="L158">            }).orElse(Optional.empty());</span>
        }

        // Finally, make random move
<span class="fc" id="L162">        return tryRandomMove(state, RANDOM, mark);</span>
    }

    // Find winning move for a player
    private Optional&lt;GameState&gt; tryWinningMove(GameState state, char mark) {
<span class="fc" id="L167">        return IntStream.range(0, BOARD_SIZE)</span>
<span class="fc" id="L168">                .boxed()</span>
<span class="fc" id="L169">                .flatMap(row -&gt; IntStream.range(0, BOARD_SIZE)</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                        .filter(col -&gt; state.board().get(row).get(col) == EMPTY_CELL)</span>
<span class="fc" id="L171">                        .mapToObj(col -&gt; new int[]{row, col}))</span>
<span class="fc" id="L172">                .map(move -&gt; tryMove(state, move[0], move[1], mark))</span>
<span class="fc" id="L173">                .filter(Optional::isPresent)</span>
<span class="fc" id="L174">                .map(Optional::get)</span>
<span class="fc" id="L175">                .filter(newState -&gt; hasWon(newState.board(), mark))</span>
<span class="fc" id="L176">                .findFirst();</span>
    }

    // Find blocking move
    private Optional&lt;GameState&gt; findBlockingMove(GameState state, char opponentMark, char ourMark) {
<span class="fc" id="L181">        return IntStream.range(0, BOARD_SIZE)</span>
<span class="fc" id="L182">                .boxed()</span>
<span class="fc" id="L183">                .flatMap(row -&gt; IntStream.range(0, BOARD_SIZE)</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                        .filter(col -&gt; state.board().get(row).get(col) == EMPTY_CELL)</span>
<span class="fc" id="L185">                        .mapToObj(col -&gt; new int[]{row, col}))</span>
<span class="fc" id="L186">                .map(move -&gt; {</span>
                    // Check if opponent would win with this move
<span class="fc" id="L188">                    Optional&lt;GameState&gt; opponentMove = tryMove(state, move[0], move[1], opponentMark);</span>
<span class="pc bpc" id="L189" title="2 of 4 branches missed.">                    if (opponentMove.isPresent() &amp;&amp; hasWon(opponentMove.get().board(), opponentMark)) {</span>
                        // Block by placing our mark there
<span class="fc" id="L191">                        return tryMove(state, move[0], move[1], ourMark);</span>
                    }
<span class="nc" id="L193">                    return Optional.&lt;GameState&gt;empty();</span>
                })
<span class="fc" id="L195">                .filter(Optional::isPresent)</span>
<span class="fc" id="L196">                .map(Optional::get)</span>
<span class="fc" id="L197">                .findFirst();</span>
    }

    /**
     * Hard AI strategy using the Minimax algorithm.
     *
     * TODO: Implement full Minimax algorithm for unbeatable AI
     * Current implementation uses medium strategy as a placeholder.
     *
     * @implNote This is a temporary implementation that will be replaced with
     *           the Minimax algorithm. The current implementation uses the
     *           medium strategy for testing purposes.
     *
     * @see #tryMediumMove(GameState, char) Current implementation
     * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Minimax&quot;&gt;Minimax Algorithm&lt;/a&gt;
     *
     * This is also an example of how I prefer to address TODOs, with enough context for any future developer to implement a solution.
     */
    public Optional&lt;GameState&gt; tryHardMove(GameState state, char mark) {
        // For now, use medium strategy (can implement minimax later)
<span class="fc" id="L217">        return tryMediumMove(state, mark);</span>
    }

    // Check if game has ended
    private Optional&lt;String&gt; checkGameEnd(GameState state, Player player1, Player player2) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (hasWon(state.board(), player1.mark())) {</span>
<span class="nc" id="L223">            return Optional.of(player1.mark() + &quot; wins&quot;);</span>
        }
<span class="nc bnc" id="L225" title="All 2 branches missed.">        if (hasWon(state.board(), player2.mark())) {</span>
<span class="nc" id="L226">            return Optional.of(player2.mark() + &quot; wins&quot;);</span>
        }
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (isDraw(state)) {</span>
<span class="nc" id="L229">            return Optional.of(&quot;Draw&quot;);</span>
        }
<span class="nc" id="L231">        return Optional.empty();</span>
    }

    // Get current player
    private Player getCurrentPlayer(GameState state, Player player1, Player player2) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        return state.currentPlayer() == player1.mark() ? player1 : player2;</span>
    }

    // Handle user move
    private GameState handleUserMove(GameState state, Scanner scanner) {
<span class="nc" id="L241">        System.out.print(&quot;Enter the coordinates: &quot;);</span>
<span class="nc" id="L242">        String input = scanner.nextLine();</span>
<span class="nc" id="L243">        return tryUserMove(state, input)</span>
<span class="nc" id="L244">                .orElseGet(() -&gt; {</span>
<span class="nc" id="L245">                    System.out.println(&quot;You should enter numbers from 1 to 3!&quot;);</span>
<span class="nc" id="L246">                    return state;</span>
                });
    }

    // Handle AI move with strategy pattern
    private GameState handleAIMove(GameState state, Player current) {
<span class="nc" id="L252">        System.out.println(&quot;Making move level \&quot;&quot; + current.type().name().toLowerCase() + &quot;\&quot;&quot;);</span>

<span class="nc bnc" id="L254" title="All 4 branches missed.">        return switch (current.type()) {</span>
<span class="nc" id="L255">            case EASY -&gt; tryRandomMove(state, RANDOM, current.mark()).orElse(state);</span>
<span class="nc" id="L256">            case MEDIUM -&gt; tryMediumMove(state, current.mark()).orElse(state);</span>
<span class="nc" id="L257">            case HARD -&gt; tryHardMove(state, current.mark()).orElse(state);</span>
<span class="nc" id="L258">            case USER -&gt; state; // Should never happen in this context</span>
        };
    }

    // Main move dispatcher using pattern matching
    private GameState makeMove(GameState state, Player current, Scanner scanner) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        return switch (current.type()) {</span>
<span class="nc" id="L265">            case USER -&gt; handleUserMove(state, scanner);</span>
<span class="nc" id="L266">            case EASY, MEDIUM, HARD -&gt; handleAIMove(state, current);</span>
        };
    }

    // Clean functional game loop
    public String playGame(GameState state, Player player1, Player player2, Scanner scanner) {
<span class="nc" id="L272">        System.out.println(formatBoard(state.board()));</span>

        // Check for game end conditions first
<span class="nc" id="L275">        Optional&lt;String&gt; gameEnd = checkGameEnd(state, player1, player2);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (gameEnd.isPresent()) {</span>
<span class="nc" id="L277">            return gameEnd.get();</span>
        }

        // Get current player and make move
<span class="nc" id="L281">        Player current = getCurrentPlayer(state, player1, player2);</span>
<span class="nc" id="L282">        GameState nextState = makeMove(state, current, scanner);</span>

        // Continue game recursively
<span class="nc" id="L285">        return playGame(nextState, player1, player2, scanner);</span>
    }

    // Parse string to PlayerType enum
    private PlayerType parsePlayerType(String typeString) {
<span class="pc bpc" id="L290" title="1 of 5 branches missed.">        return switch (typeString.toLowerCase()) {</span>
<span class="fc" id="L291">            case &quot;user&quot; -&gt; PlayerType.USER;</span>
<span class="fc" id="L292">            case &quot;easy&quot; -&gt; PlayerType.EASY;</span>
<span class="fc" id="L293">            case &quot;medium&quot; -&gt; PlayerType.MEDIUM;</span>
<span class="fc" id="L294">            case &quot;hard&quot; -&gt; PlayerType.HARD;</span>
<span class="nc" id="L295">            default -&gt; throw new IllegalArgumentException(&quot;Unknown player type: &quot; + typeString);</span>
        };
    }

    // Main parcing method that associates user input with an enum
    public Optional&lt;GameConfig&gt; parseCommand(String input) {
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (input.matches(&quot;start (user|easy|medium|hard) (user|easy|medium|hard)&quot;)) {</span>
<span class="fc" id="L302">            String[] parts = input.split(&quot; &quot;);</span>
            try {
<span class="fc" id="L304">                return Optional.of(new GameConfig(</span>
<span class="fc" id="L305">                        new Player(&quot;Player 1&quot;, 'X', parsePlayerType(parts[1])),</span>
<span class="fc" id="L306">                        new Player(&quot;Player 2&quot;, 'O', parsePlayerType(parts[2]))</span>
                ));
<span class="nc" id="L308">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L309">                return Optional.empty();</span>
            }
        }
<span class="fc" id="L312">        return Optional.empty();</span>
    }

    /**
     * Main game loop that handles user input and game initialization.
     * This method:
     * 1. Creates a Scanner for user input
     * 2. Enters an infinite loop until &quot;exit&quot; is entered
     * 3. Parses user commands for game configuration
     * 4. Initializes and starts the game when valid configuration is provided
     */
    public void displayMenu() {
<span class="nc" id="L324">        Scanner scanner = new Scanner(System.in);</span>
        while (true) {
<span class="nc" id="L326">            System.out.print(&quot;Input command: &quot;);</span>
<span class="nc" id="L327">            String input = scanner.nextLine();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (input.equals(&quot;exit&quot;)) {</span>
<span class="nc" id="L329">                System.out.println(&quot;Exiting...&quot;);</span>
<span class="nc" id="L330">                return;</span>
            }
<span class="nc" id="L332">            Optional&lt;GameConfig&gt; config = parseCommand(input);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (config.isPresent()) {</span>
<span class="nc" id="L334">                GameState initialState = new GameState(</span>
<span class="nc" id="L335">                        createEmptyBoard(BOARD_SIZE, EMPTY_CELL), 'X', 0);</span>
<span class="nc" id="L336">                System.out.println(playGame(initialState, config.get().player1(), config.get().player2(), scanner));</span>
<span class="nc" id="L337">            } else {</span>
<span class="nc" id="L338">                System.out.println(&quot;Bad parameters! Expected: start &lt;player1&gt; &lt;player2&gt;&quot;);</span>
<span class="nc" id="L339">                System.out.println(&quot;Available types: user, easy, medium, hard&quot;);</span>
            }
<span class="nc" id="L341">        }</span>
    }

    /**
     * JDBC connection URL for Oracle database.
     *
     * TODO: Update with dynamic JDBC URL configuration
     * Current implementation uses hardcoded local development URL:
     * - Host: localhost
     * - Port: 1521
     * - Service: XE
     *
     * @implNote This is a temporary hardcoded value that should be replaced with
     *           a configuration-based approach for different environments
     *
     * @see java.sql.Connection
     * @see java.sql.DriverManager
     */
    public void saveGameState(GameState state) {
<span class="nc" id="L360">        String jdbcUrl = &quot;jdbc:oracle:thin:@localhost:1521/XE&quot;; // TODO: Update with jdbcUrl which is created by</span>
<span class="nc" id="L361">        String username = &quot;tictactoe&quot;;</span>
<span class="nc" id="L362">        String password = &quot;password&quot;;</span>
<span class="nc" id="L363">        String sql = &quot;INSERT INTO game_states (board, current_player, move_count) VALUES (?, ?, ?)&quot;;</span>

<span class="nc" id="L365">        try (Connection conn = DriverManager.getConnection(jdbcUrl, username, password);</span>
<span class="nc" id="L366">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
<span class="nc" id="L367">            String boardString = state.board().stream()</span>
<span class="nc" id="L368">                    .flatMap(List::stream)</span>
<span class="nc" id="L369">                    .map(String::valueOf)</span>
<span class="nc" id="L370">                    .collect(Collectors.joining());</span>
<span class="nc" id="L371">            stmt.setString(1, boardString);</span>
<span class="nc" id="L372">            stmt.setString(2, String.valueOf(state.currentPlayer()));</span>
<span class="nc" id="L373">            stmt.setInt(3, state.moveCount());</span>
<span class="nc" id="L374">            stmt.executeUpdate();</span>
<span class="nc" id="L375">        } catch (SQLException e) {</span>
<span class="nc" id="L376">            e.printStackTrace();</span>
<span class="nc" id="L377">        }</span>
<span class="nc" id="L378">    }</span>

    /**
     * Entry point for the game.
     * Creates a new instance of FunctionalGame and starts the game loop.
     */
    public static void main(String[] args) {
<span class="nc" id="L385">        new FunctionalGame().displayMenu();</span>
<span class="nc" id="L386">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>